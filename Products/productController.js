import fs from "fs";
import path from "path";
import {
  createBulkProductsService,
  createProductService,
  deleteProductService,
  downloadExcelTemplateService,
  generateProductQrPdfService,
  getAllProductsService,
  getProductByUniqueIdService,
  updateProductService,
} from "./productService.js";
import { errorResponse, successResponse } from "../utils/responseHandler.js";

export const createProductController = async (req, res) => {
  try {
    const tenantId = req.headers["x-tenant-id"];

    const data = req.body;

    let product_image;
    let product_images = [];

    if (req.files?.product_image && req.files.product_image.length > 0) {
      product_image = `/uploads/productsImages/${req.files.product_image[0].filename}`;
    }

    if (req.files?.product_images && req.files.product_images.length > 0) {
      product_images = req.files.product_images?.map((file) => `/uploads/productsImages/${file.filename}`);
    }

    console.log(product_image, "product_image");
    console.log(product_images, "product_images");

    const inputData = {
      ...data,
      product_image,
      product_images,
    };

    const createdProduct = await createProductService(tenantId, inputData);
    res.status(201).json(successResponse("Product created successfully", { data: createdProduct }));
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};

export const getAllProductsController = async (req, res) => {
  try {
    const filters = req.query;
    const tenantId = req.headers["x-tenant-id"];
    const { data, totalCount } = await getAllProductsService(tenantId, filters);
    res.status(200).json(successResponse("Products fetched successfully by search filters", { totalCount, data }));
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};

// Product Id generated by admin
export const getProductByIdController = async (req, res) => {
  try {
    const { id } = req.params; // This is products_unique_ID
    const tenantId = req.headers["x-tenant-id"];

    if (!id) {
      return res.status(400).json(errorResponse("products_unique_ID is required in URL"));
    }

    const response = await getProductByUniqueIdService(tenantId, id);
    res.status(200).json(successResponse("Product fetched successfully", { data: response }));
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};

export const updateProductController = async (req, res) => {
  try {
    const { id } = req.params;
    const productData = req.body;
    const tenantId = req.headers["x-tenant-id"];
    if (!id) {
      return res.status(400).json(errorResponse("products_unique_ID is required in URL"));
    }

    if (req.files) {
      if (req.files.product_image && req.files.product_image.length > 0) {
        productData.product_image = req.files.product_image[0].path;
      }

      if (req.files.product_images && req.files.product_images.length > 0) {
        productData.product_images = req.files.product_images.map((file) => file.path);
      }
    }

    const response = await updateProductService(tenantId, id, productData);
    res.status(200).json(successResponse("Product updated successfully", { data: response }));
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};

export const deleteProductController = async (req, res) => {
  try {
    const { id } = req.params; // products_unique_ID
    const tenantId = req.headers["x-tenant-id"];

    if (!id) {
      return res.status(400).json(errorResponse("Product unique ID is required in URL"));
    }

    const existingProduct = await deleteProductService(tenantId, id);

    const deleteFileIfExists = (filePath) => {
      if (!filePath) return;

      let cleanedPath = filePath
        .replace(/\\/g, "/")
        .replace("/uploads/productsImages/", "/uploads/productImages/")
        .replace(/^\/+/, "");

      const fullPath = path.resolve(process.cwd(), cleanedPath);

      try {
        if (fs.existsSync(fullPath)) {
          fs.unlinkSync(fullPath);
          console.log("Deleted:", fullPath);
        } else {
          console.warn("File not found:", fullPath);
        }
      } catch (err) {
        console.warn("Failed to delete:", fullPath, err.message);
      }
    };

    // Delete main and multiple product images
    if (existingProduct.product_image) {
      deleteFileIfExists(existingProduct.product_image);
    }

    if (Array.isArray(existingProduct.product_images)) {
      existingProduct.product_images.forEach(deleteFileIfExists);
    }
    res.status(200).json(successResponse("Product deleted successfully", { data: existingProduct }));
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};

export const downloadExcelTemplateController = async (req, res) => {
  try {
    const tenantId = req.headers["x-tenant-id"];
    const { id: category_unique_ID } = req.params; // category_unique_ID

    const workbook = await downloadExcelTemplateService(tenantId, category_unique_ID);

    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    res.setHeader("Content-Disposition", "attachment; filename=product_template.xlsx");

    await workbook.xlsx.write(res);
    res.end();
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};

export const createBulkProductsController = async (req, res) => {
  try {
    const tenantId = req.headers["x-tenant-id"];
    // const { id: category_unique_id } = req.params;

    const { category_unique_id } = req.body;
    const response = await createBulkProductsService(tenantId, category_unique_id, req.file.path);
    res.status(201).json(successResponse("Bulk products created successfully", { data: response }));
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};

export const generateProductQrPdfController = async (req, res) => {
  try {
    const tenantId = req.headers["x-tenant-id"];
    const { id: product_unique_id } = req.params;
    let { quantity } = req.body;

    quantity = parseInt(quantity) || 1;

    const { pdfBuffer, fileName } = await generateProductQrPdfService(tenantId, { product_unique_id, quantity });

    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename=${fileName}`);

    res.send(pdfBuffer);
  } catch (error) {
    res.status(500).json(errorResponse(error.message, error));
  }
};
// MongoDb id generated by db
// export const getProductByIdController = async (req, res) => {
//   try {
//     const { id } = req.params; // This is product id
//     const tenantId = req.headers["x-tenant-id"];

//     if (!id) {
//       return res.status(400).json({
//         status: "Failed",
//         message: "products_unique_ID is required in URL",
//       });
//     }

//     const response = await getProductByIdServices(tenantId, id);

//     res.status(200).json({
//       status: "Success",
//       message: "Product fetched successfully",
//       data: response,
//     });
//   } catch (error) {
//     console.error("Error in getProductByIdController ===>", error.message);
//     res.status(500).json({
//       status: "Failed",
//       message: "Failed to fetch product",
//       error: error.message,
//     });
//   }
// }

// export const getProductsBysubUniqeIDController = async (req, res) => {
//   try {
//     const { id } = req.params; // This ID is  Category unique ID
//     const tenantId = req.headers["x-tenant-id"];
//     if (!id) {
//       return res.status(400).json({
//         status: "Failed",
//         message: "subCategory_unique_ID is required in URL",
//       });
//     }

//     const response = await getProductsBySubUniqueIDServices(tenantId, id);

//     if (!response || response.length === 0) {
//       return res.status(404).json({
//         status: "Failed",
//         message: "No products found for this subCategory_unique_ID",
//       });
//     }

//     res.status(200).json({
//       status: "Success",
//       message: "Products fetched successfully by subCategory_unique_ID",
//       data: response,
//     });
//   } catch (error) {
//     console.error(
//       "Error in getProductsBysubUniqeIDController ===>",
//       error.message
//     );
//     res.status(500).json({
//       status: "Failed",
//       message: "Failed to fetch products",
//       error: error.message,
//     });
//   }
// };
